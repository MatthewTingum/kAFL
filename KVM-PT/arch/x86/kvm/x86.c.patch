--- x86.c	2016-06-07 20:23:53.000000000 -0500
+++ x86.c.patched	2019-01-10 13:04:24.525293264 -0600
@@ -2687,6 +2687,12 @@
 		r = 0;
 		break;
 	}
+#ifdef CONFIG_KVM_VMX_PT
+	case KVM_VMX_PT_SUPPORTED: {
+		r = kvm_x86_ops->vmx_pt_enabled();
+		break;
+	}
+#endif
 	default:
 		r = -EINVAL;
 	}
@@ -3496,6 +3502,12 @@
 		r = kvm_vcpu_ioctl_enable_cap(vcpu, &cap);
 		break;
 	}
+#ifdef CONFIG_KVM_VMX_PT
+	case KVM_VMX_PT_SETUP_FD: {
+		r = kvm_x86_ops->setup_trace_fd(vcpu);
+		break;
+	}
+#endif
 	default:
 		r = -EINVAL;
 	}
@@ -5968,7 +5980,91 @@
 		a3 &= 0xFFFFFFFF;
 	}
 
+#ifdef CONFIG_KVM_VMX_PT
+	/* kAFL Hypercall Interface (ring 0) */
+	if(kvm_x86_ops->get_cpl(vcpu) == 0) {
+		r = 0;
+		if (kvm_register_read(vcpu, VCPU_REGS_RAX) == HYPERCALL_KAFL_RAX_ID){
+			switch(kvm_register_read(vcpu, VCPU_REGS_RBX)){
+				case 8: /* PANIC */   
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_PANIC;    
+					break;
+				case 9: /* KASAN */ 
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_KASAN; 
+					break;
+				default:
+					r = -KVM_EPERM;   
+					break;   
+			}
+			return r;
+		}
+	}
+#endif
+
 	if (kvm_x86_ops->get_cpl(vcpu) != 0) {
+		/* kAFL Hypercall interface */
+		#ifdef CONFIG_KVM_VMX_PT
+		if (kvm_register_read(vcpu, VCPU_REGS_RAX) == HYPERCALL_KAFL_RAX_ID){
+			r = 0;
+			switch(kvm_register_read(vcpu, VCPU_REGS_RBX)){
+				case 0:  /* KAFL_GUEST_ACQUIRE */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_ACQUIRE;
+					break;
+				case 1:  /* KAFL_GUEST_GET_PAYLOAD */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_GET_PAYLOAD;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX);
+					break;
+				case 2:  /* KAFL_GUEST_GET_PROGRAM */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_GET_PROGRAM;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX);
+					break;
+				case 3: /* KAFL_GUEST_GET_ARGV */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_GET_ARGV;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX);
+					break;
+				case 4: /* KAFL_GUEST_RELEASE */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_RELEASE;
+					break;
+				case 5: /* KAFL_GUEST_SUBMIT_CR3 */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_SUBMIT_CR3;
+					vcpu->run->hypercall.args[0] = kvm_read_cr3(vcpu);
+					break;
+				case 6: /* KAFL_GUEST_PANIC */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_SUBMIT_PANIC;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX); 
+					break;
+				case 7: /* KAFL_GUEST_KASAN */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_SUBMIT_KASAN;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX); 
+					break;
+				case 10: /* LOCK */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_LOCK;
+					break;
+				case 11: /* INFO */    
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_INFO;
+                    vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX);
+					break;
+				case 12: /* KAFL_GUEST_NEXT_PAYLOAD */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_NEXT_PAYLOAD;
+					break;
+				case 13: /* KAFL_GUEST_DEBUG */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_DEBUG;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX);
+					break;
+				case 16: /* KAFL_GUEST_SUBMIT_ADDR */
+					vcpu->run->exit_reason = KVM_EXIT_KAFL_SUBMIT_ADDR;
+					vcpu->run->hypercall.args[0] = kvm_register_read(vcpu, VCPU_REGS_RCX);	// AddrN
+					vcpu->run->hypercall.args[1] = kvm_register_read(vcpu, VCPU_REGS_RDX);	// IPa
+					vcpu->run->hypercall.args[2] = kvm_register_read(vcpu, VCPU_REGS_R8);	// IPb
+					break;
+				default:
+					r = -KVM_EPERM;
+					break;
+			}
+			return r;
+		}
+		#endif
+
 		ret = -KVM_EPERM;
 		goto out;
 	}
